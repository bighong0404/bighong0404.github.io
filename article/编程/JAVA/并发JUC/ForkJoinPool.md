







[什么是ForkJoinPool异步模式]: https://www.codenong.com/5640046/

```
先把初始化工作队列这块逻辑搞清楚，然后去看 窃取的逻辑。

这个线程池 有两组 workqueue，一组是分配给每个线程的，每个线程占用一个workqueue 这个workqueue 使用的是 同步模式 LIFO ，还有一组workqueue是共享的workqueue，这组存储的任务为 共享任务，咱们使用 forkjoinpool 时初次提交的任务 要交给 “共享队列”，提交给共享队列的任务 会被 工作线程 窃取走，窃取到这个任务的线程 执行这个任务，假设这个任务 在执行期间 产生了子任务，并且咱们的上层任务 需要 子任务数据的话，那需要把子任务放到 线程自身的 任务队列内。先进后出 你可以认为这是一个栈结构，先进去的任务 需要 后进去任务的结果，越底层的任务，颗粒度越粗。共享队列 先进先出 这个好理解，提交最初始的任务 会提交到 共享队列，这些最初始的任务 他们之间没有因果关系，所以要遵循 提交顺序去执行。

fork就是向线程自身的队列 入栈一个任务，一般fork之后，下一行代码就是 join 刚刚fork提交的任务…所以是 FILO 队列
```

