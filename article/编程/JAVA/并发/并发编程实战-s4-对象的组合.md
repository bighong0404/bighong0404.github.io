为了方便编程, 以下是现有的线程安全的对象组合模式. 

> 在设计线程安全类的过程中, 需要包含以下三个基本要素:
> * 找出构成对象状态的所有变量
> * 找出约束状态变量的不变性条件(状态值边界条件, 即状态值的有效范围)
> * 建立对象状态的并发访问管理策略

> * 类的不变性条件与后验条件(状态值变更完成后的有效性检查)约束了对象在哪些状态和状态转换是有效的. 但有些操作方法中包含了基于状态的先验条件, 这叫依赖状态的操作. 
> * 操作方法中有不变性条件, 后验条件约束, 先验条件约束, 那么该操作需要同步与封装. 

> #### 实例封装
> * 若某个对象不是线程安全的, 可以通过多重技术使其在多线程环境中安全地使用. 实例封装是最简单的方式. 
> * 实例封装是把非线程安全的数据对象封装在另一个对象内部,  将数据对象的访问限制在对象的方法上, 从而确保线程在访问数据时候总能持有正确的锁.
> * 例子: 包装器工厂方法通过装饰器模式将容器封装在一个同步的包装器对象中, 包装器对象每个方法都是同步的, Collection.synchronizedList

> Java监视器模式
> 把对象的所有可变状态都封装起来, 并由对象自己的内置锁来保护. 

> #### 线程安全性的委托
> 当类中各个组件(状态变量)都是线程安全的, 视情况可能还需要再增加一层额外的线程安全层(锁, 同步).
>
> * 若多个状态变量是线程安全并且相互独立, 那么类的线程安全性可以委托给状态变量, 不需要额外的线程安全层.
> * 若多个状态变量存在耦合关系, 例如先验条件, 那个这个类需要增加一层额外的线程安全层, 即提供自己的加锁机制以保证这些复合操作都是原子操作.

> #### 在现有的线程安全类中添加功能
> 1.修改原始的类, 这是最安全的, 但通常无法做到
> 2.拓展extends这个类, 但类的同步策略实现会被分布到多个独立维护的源码文件中(线程安全的父类跟拓展出来的子类), 若父类的同步策略被修改, 那么子类的同步策略会被破坏. 
> 3.拓展类的功能, 并不是拓展类本身, 而是将拓展代码放入一个"辅助类中", 辅助类持有线程安全的类, 增加方法来操作这个类. 需要注意的是,  新增的方法, 需要获取类的锁(客户端加锁, 使用synchronized(obj)代码, 而不是用synchronized去修饰方法).
> 4.组合, 参考Collection.synchronizedList. 

> #### 同步策略文档化, 给使用者提供参考, 防止使用者瞎猜所使用的类是否是线程安全的. 
