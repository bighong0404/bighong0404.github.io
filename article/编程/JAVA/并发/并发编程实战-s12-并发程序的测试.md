> 并发测试大致分为**安全性测试**和**活跃性测试**. 
> 安全性可以定位为"不发生任务错误的行为", 活跃性可以定义为"某个良好的行为终究会发生".

* 安全性测试通常会采用**测试不变性条件**的形式, 即判断某个类的行为是否与其规范保持一致.
* 活跃性测试包括**进展测试**和**无进展测试**两方面.
* 与活跃性相关的是性能测试: **吞吐量**(一组并发任务中已完成任务所占的比例), **响应性**(请求从发出到完成消耗的时间, 也成为延迟), **可伸缩性**(增加机器资源, 吞吐也响应提升).

 ps: [Doug Lea老板创建的concurrency包测试类目录](http://gee.cs.oswego.edu/cgi-,bin/viewcvs.cgi/jsr166/src/test/tck), 其中可以注意[JSR166TestCase并发测试基类](http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java)

## 12.1 正确性测试

> 找出需要检测的不变性条件和后验条件, 在编写测试的过程中不断发现新的规范条件.

#### 1) 基本的单元测试

* 使用串行方式调用各个方法, 并验证它的不变性条件和后验条件.

#### 2) 对阻塞操作的测试

* 阻塞是并发的基本属性, 测试时候需要引入多线程.
* 测试阻塞方法时, 只有当线程不再继续执行, 测试才算是成功的.
* 方法成功阻塞后, 使用**中断**来让解除阻塞.
* 不要使用```Thread.getState```来验证线程是否在阻塞状态. 因为JVM实现阻塞的方式有**自旋等待**和**调用系统命令挂起线程**. 自旋等待时候线程是状态是**RUNNABLE**, 被挂起线程的状态才是**WAITING或者TIMED_WAITING**.

#### 3) 安全性测试

> 在构建对并发类的安全性测试中, 需要解决的关键问题在于, 要找出那些容易检查的属性, 这些属性在发生错误的情况下极有可能失败, 同时又不会使得错误检查代码人为地限制并发性. 理想情况是, 在测试属性中不需要任务同步机制. 
* 并发类的测试程序, 自身就是一个并发程序, 并且应该放在**多处理器**的系统上运行.
* 使用随机生成的数据来测试, 由于大多随机数生成类是线程安全的, 并且会带来额外的同步开销, 因此在随机数生成过程中, 有可能会在这些类与执行时序之间产生耦合关系. 
* 若不需要高质量的随机性, 只要确保在不同的测试运行中都有不同的数字, 那么下面的代码非常合适.
```
    /**
     * 由调用方生成随机数seed
     * 生成方法: int seed = this.hashCode() ^ (int) System.nanoTime();
     * @param seed
     * @return
     */
    public static int xorShift(int seed){
        seed ^= (seed << 6);
        seed ^= (seed >>> 21);
        seed ^= (seed << 7);
        return seed;
    }
```

####4)  资源管理的测试
* 资源泄露问题, 使用堆检查工具
* -XX:+DisableExplicitGC, 告诉JVM忽略System.gc的调用. 有助于帮助暴露资源泄露问题

#### 5) 使用回调

1. 回调的执行通常是在对象什么周期的一些已知位置上, 并且在这些位置上非常适合判断不变性条件是否被破坏.
2. 例如通过自定义的ThreadFactory, 可以对线程池的线程创建进行控制和监控. 

#### 6) 产生更多的交替操作

* 并发程序的大多错误都是低概率时间, 因此需要多次执行测试. 但有方法可以提高发现错误的概率: 产生更多的交替行为(上下文切换).
* 提高交替操作数量的有效方法: 在范围共享状态的操作中, 使用```Thread.yield```可以产生更多的上下文切换.
---
## 12.2 性能测试

* 性能测试通常是功能测试的延伸, 虽然两者有重叠之处, 但目标是不同的. 
* 性能测试第一个目标是测试**端到端性能(效率/吞吐)**, 第二个目标是根据经验值来调整各种不同的**限值**(线程数量, 缓存容量等).
---
## 12.3 避免性能测试的陷阱
#### 1) 垃圾回收

* 垃圾回收的执行时序是无法预测的, 因此在测试时候, 有可能执行了N次迭代也没触发垃圾回收, 但在N+1次迭代时缺触发了,  这将对测试时间带来影响.
* 防止垃圾回收对测试结果产生偏差有两种策略: 
1)确保垃圾回收操作在测试期间都不会执行, ```-verbose:gc```, 看看是否执行了垃圾回收
2)```推荐```确保垃圾回收操作在测试期间多次执行, 更能充分反映内存分配和垃圾回收等开销.

#### 2) 动态编译

* 当某个类第一次被加载时, JVM会通过**解译字节码**的方式来执行, 这是**解释执行**方式. 在某个时刻, 如果一个方法运行的次数足够多, 那么**动态编译器**会将它编译为**机器代码**, 这时候执行方式是**直接执行.**
* 动态编译的执行时间是无法预测的. 防止动态编译对测试结果产生偏差方式
1)是程序运行足够长时间(至少几分钟), 这样子编译过程以及解释执行只占总运行时间的很小一部分. 
2)在测试之前先使代码运行一段时间, 等被完全编译后才进行测试. ```-xx:+PrintCompilation```, 当动态编译运行时将输出一条信息, 能帮助判断是否动态编译是否完成了.

#### 3) 对代码路径的不真实采样
#### 4) 不真实的竞争程度
#### 5) 无用代码的消除

* **优化编译器**会消除对输出结果无任何影响的无用代码. 
* ```-server```模式的编译器会对代码进行优化, 会比```-client```模式运行得更好. 因此无论在正式产品还是测试版本, 都应该使用```-server```模式
---
## 12.4 其他测试方法
#### 1)人工代码审查
#### 2)静态分析工具

* 例如Findbugs, 包含了许多错误模式检查器, 能检测出多种常见错误: 调用```Thread.run```来执行线程, 未被释放的锁, 空同步块, 条件等待的错误, 对Lock和Condition的误用等等..
####3)面向方面(AOP)的测试技术
####4)分析与检测工具
* 内置的JMX提供优先的功能来检测线程行为.
