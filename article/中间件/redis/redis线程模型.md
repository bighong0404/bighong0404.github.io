> 参考: <<redis设计与实现>>



Redis服务器是典型的一对多服务器程序, 通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。



## 单线程模型为何效率高

- 纯内存操作
- 基于非阻塞的IO多路复用机制
- 避免了多线程的频繁上下文切换



# 文件事件处理器

Redis 基于 Reactor 模式开发了自己的网络事件处理器 - **文件事件处理器**（file event handler，后文简称为 `FEH`），而该处理器又是单线程的，所以redis设计为单线程模型。

- 采用**I/O多路复用**同时监听多个socket，根据socket当前执行的事件来为 socket 选择对应的事件处理器。
- 当被监听的socket准备好执行`连接应答（accept）`、`读取（read）`、`写入（write）`、`关闭（close）`等操作时，和操作对应的文件事件就会产生，这时FEH就会调用socket之前关联好的事件处理器来处理对应事件。

所以虽然FEH是单线程运行，但通过I/O多路复用监听多个socket，不仅实现高性能的网络通信模型，又能和 Redis 服务器中其它同样单线程运行的模块交互，保证了Redis内部单线程模型的简洁设计。



文件事件处理器的四个组成部分: **套接字(Socket)**、**I/O多路复用程序**、**文件事件分派器**（dispatcher），以及**事件处理器**。

![image-20210219164548289](img/image-20210219164548289.png)

## 套接字Socket与文件事件

文件事件是对Socket操作的抽象，每当一个Socket准备好执行`连接应答（accept）、写入、读取、关闭`等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个Socket，所以多个文件事件有可能会并发地出现。



## I/O多路复用程序

I/O多路复用程序负责监听多个Socket，并向文件事件分派器传送那些产生了事件的Socket。

尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会**将所有产生事件的Socket都放到一个队列**里面，然后通过这个队列，以**有序（sequentially）、同步（synchronously）、每次一个Socket**的方式向文件事件分派器传送Socket。**当上一个Socket产生的事件被处理完毕之后（该Socket为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向文件事件分派器传送下一个Socket**。

![image-20210219164706785](img/image-20210219164706785.png)

I/O多路复用程序的所有功能都是通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c，诸如此类。

![img](img/image-20210219170119637.png)



因为Redis为每个I/O多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换的。

![image-20210219170119638](img/image-20210219170119638.png)



>所有异步I / O子系统都有不同的内部结构，但是在当前特定情况下，这些具体的异步I / O库用于支持尽可能多的平台。那是:
>
>- evport = Solaris 10
>
>- epoll = Linux
>
>- kqueue = OS X，FreeBSD
>
>- select =  作为 POSIX 标准中的系统调用，在不同版本的操作系统上都会实现
>
>`Evport`，`Epoll`和`KQueue`具有 **O(1)**描述符选择算法复杂度，并且它们都使用内部内核空间内存结构。他们还可以提供**很多**(数十万个)文件描述符。
>
>`select`最多只能为**提供最多1024个**描述符，并且对描述符进行完全扫描(因此每次迭代所有描述符以选择一个可使用的描述符)，因此复杂度为 **O(n)**。

如果当前编译环境没有`evport, epoll, kqueue`函数，就会选择 `select` 作为备选方案. 由于其在使用时会扫描全部监听的描述符，所以其时间复杂度较差 O(n)O(n)，并且只能同时服务 1024 个文件描述符，所以一般并不会以 `select` 作为第一方案使用。 



## 文件事件分派器

文件事件分派器接收I/O多路复用程序传来的Socket，并根据Socket产生的事件的类型，调用相应的事件处理器。



## 文件事件的处理器



## 事件类型

I/O 多路复用程序可以监听多个socket的 `ae.h/AE_READABLE` 事件和 `ae.h/AE_WRITABLE` 事件， 这两类事件和Socket操作之间的对应关系如下：

- 当socket可读（比如客户端对Redis执行`write`/`close`操作），或有新的可应答的socket出现时（即客户端对Redis执行`connect`操作），socket就会产生一个`AE_READABLE`事件
- 当socket可写时（比如客户端对Redis执行read操作），socket会产生一个`AE_WRITABLE`事件。

I/O多路复用程序可以同时监听`AE_REABLE`和`AE_WRITABLE`两种事件，要是一个socket同时产生这两种事件，那么文件事件分派器优先处理`AE_REABLE`事件。即**一个socket又可读又可写时， Redis服务器先读后写socket**。



## 事件处理器

服务器会为执行不同任务的Socket关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。

- **应答处理器**: 为了对连接服务器的各个客户端进行应答，服务器要为监听Socket关联连接应答处理器。

- **命令请求处理器**: 为了接收客户端传来的命令请求，服务器要为客户端Socket关联命令请求处理器。

- **命令回复处理器**: 为了向客户端返回命令的执行结果，服务器要为客户端Socket关联命令回复处理器。

- **复制处理器**: 当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。



**一次完整的客户端与服务器连接事件示例**

假设一个Redis服务器正在运作，那么这个服务器的监听Socket的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。

如果这时有一个Redis客户端向服务器发起连接，那么监听Socket将产生AE_READABLE事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端Socket，以及客户端状态，并将客户端Socket的AE_READABLE事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。

之后，假设客户端向主服务器发送一个命令请求，那么客户端Socket将产生AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。

执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端Socket的AE_WRITABLE事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端Socket将产生AE_WRITABLE事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入到Socket之后，服务器就会解除客户端Socket的AE_WRITABLE事件与命令回复处理器之间的关联。

![image-20210219172642592](img/image-20210219172642592.png)



# 单线程IO的瓶颈

虽然是单线程，动辄能上10W QPS, 但很难进一步提升。

因为这个模型有几个缺陷：

- 只能用一个cpu核(忽略后台线程)
- 如果value比较大，redis的QPS会下降得很厉害，有时一个大key就可以拖垮



redis主线程的时间消耗主要在两个方面：

- 逻辑计算的消耗
- 同步IO读写，拷贝数据导致的消耗

当value比较大时，瓶颈会先出现在同步IO上(假设带宽和内存足够)，这部分消耗在于两部分：

- 从socket中读取请求数据，会从内核态将数据拷贝到用户态 （read调用）
- 将数据回写到socket，会将数据从用户态拷贝到内核态 （write调用）

这部分数据读写会占用大量的cpu时间，也直接导致了瓶颈。 

**如果能有多个线程来分担这部分消耗，那redis的吞吐量还能更上一层楼，这也是redis引入多线程IO的目的**。





# Redis6.0 - 多线程IO



核心思路是，将主线程的 IO 读写任务拆分出来给一组独立的线程执行，使得多个 socket 的读写可以并行化。

**Redis 的IO多线程只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程**。之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。



**开启多线程**

默认情况下，Redis多线程是禁用的，我们可以在配置文件选择开启：

```properties
#开启IO多线程
io-threads-do-reads yes
#配置线程数量，如果设为1就是主线程模式。
io-threads 4
```

> 官方建议：至少4核的机器才开启IO多线程，并且除非真的遇到了性能瓶颈，否则不建议开启此配置 ，且配置的线程数少于机器总线程数，如果有4核建议开启2,3个线程，如果有8核建议开6线程。 线程并不是越多越好，多于8个线程意义不大。



**性能据测试提升了一倍以上**

![image-20210219175620895](img/image-20210219175620895.png)

![image-20210219175640403](img/image-20210219175640403.png)