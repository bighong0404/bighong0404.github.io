# Redis持久化机制



>  Redis持久化的意义，在于故障恢复。可以归到高可用范围内。



如果通过持久化将数据搞一份儿在磁盘上去，然后定期同步和备份到一些云存储服务上去，那么就保证数据不丢失全部，还是可以恢复一部分数据回来的。



## 1. RDB与AOF两种持久化机制的介绍



### 1.1 RDB(Redis DataBase)持久化机制

redis中的数据执行周期性(见conf配置的`SNAPSHOTTING说明`)的全量快照备份.

存储的是内存数据的二进制序列化形式，存储上非常紧凑。redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。



#### RDB持久化机制的工作流程

(1) redis根据配置的多个检查点(`save xxx xxx`)去生成rdb快照文件
(2) fork一个子进程出来, 子进程尝试将数据dump到临时的rdb快照文件中
(3) 完成rdb快照文件的生成之后，就替换之前的旧的快照文件dump.rdb，每次生成一个新的快照，都会覆盖之前的老快照



`redis-cli SHUTDOWN` 是一种安全退出的模式，在退出redis时会立即生成一份dump.rdb快照.



### 1.2 AOF(Append Only File)机制

#### 1.2.1 介绍

对每条写入命令作为日志，以append-only的模式写入一个日志文件中。 当有**写指令**, redis会写到linux系统的**os cache**, 默认每隔1s调用系统`fsync`指令强制把os cache的数据刷到磁盘文件。 

因为append写指令, 因此aof文件会持续膨胀，不会删除过期数据。当aof文件太大了, redis会做`rewrite`操作, 基于当前redis内存中的数据来构造一个新aof文件, 然后删除旧的很大的aof文件.

在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集。



#### 1.2.2 AOF持久化配置设置

**开启**  `AOF`默认是关闭的, 需要修改`appendonly yes`

**刷盘策略**

```conf
 # appendfsync always 每次写操作都刷盘,  QPS会降低到1,2k
appendfsync everysec  默认配置, 每秒执行一次fsync主动刷盘
# appendfsync no      不主动刷盘, 依赖系统os cache刷盘策略, 不可控
```



#### 1.2.3 AOF rewrite

**触发条件**

```conf
auto-aof-rewrite-percentage 100  当前aof文件比上次redis记录的aof文件增大的百分数 
auto-aof-rewrite-min-size 64mb   aof文件最小大小
```



**rewrite过程**

(1) redis fork一个子进程
(2) 子进程基于当前内存中的数据，构建日志，开始往一个新的临时的AOF文件中写入日志
(3) redis主进程，接收到client新的写操作之后，在内存中写入日志，同时新的日志也继续写入旧的AOF文件
(4) 子进程写完新的日志文件之后，redis主进程将内存中的新日志再次追加到新的AOF文件中
(5) 用新的日志文件替换掉旧的日志文件



#### 1.2.4 AOF 破损文件的修复

用`redis-check-aof --fix aof文件名`命令来修复破损的AOF文件.  会把aof文件中损坏的命令删除. 



### 1.3 AOF和RDB同时工作

(1) 如果RDB在执行snapshotting操作，那么redis不会执行AOF rewrite; 如果redis再执行AOF rewrite，那么就不会执行RDB snapshotting
(2) 如果RDB在执行snapshotting，此时用户执行BGREWRITEAOF命令，那么等RDB快照生成之后，才会去执行AOF rewrite
(3) 同时有RDB snapshot文件和AOF日志文件，那么redis重启的时候，会优先使用AOF进行数据恢复，因为其中的日志更完整
(4) 如果想要redis仅仅作为纯内存的缓存来用，那么可以禁止RDB和AOF所有的持久化机制。







## 2. RDB持久化机制的优点

(1) RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备.  AOF也可以做冷备, 但需要自己写指令. 

(2) redis在生成RDB文件备份时候, 是fork一个子进程去执行磁盘IO操作, redis主进程依旧对外提供的读写服务，影响小.

(3) RDB, 每次写数据都是直接写内存. 而AOF会同时写入os cache, 多了时间开销. 

(4) RDB数据文件是内存数据的二进制序列化形式, 来重启和恢复redis进程，直接加载进内存就行, 更加快速. 



## 3. RDB持久化机制的缺点

(1) 由于是周期性全备份, 因此会丢失增量数据.  这是RDB最大的缺点, 也是不适合做第一优先的恢复方案的原因. 

(2) RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒. 



## 4. AOF持久化机制的优点

(1) AOF可以更好的**保护数据不丢失**，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据.

(2) AOF日志文件以append-only模式写入，所以**没有任何磁盘寻址的开销，写入性能非常高**，而且文件不容易破损，即使文件尾部破损，也很容易修复. 

(3) AOF日志文件即使过大的时候，出现后台`rewrite`操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。

(4) AOF日志文件保存的**指令内容是可读**的，可以手动修改内容. 这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。



## 5. AOF持久化机制的缺点

(1) 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大.

(2) AOF开启后，支持的写QPS会比RDB支持的写QPS低，因此AOF一般会配置成每秒fsync一次日志文件。当然，每秒一次fsync，性能也还是很高的。也可以设置同步fsync，确保丢失数据，但redis的QPS大大减低。

(3) 数据恢复的时候，会比较慢。

(4) 不适合冷备。需要要自己手写复杂的脚本去实现。



## 6.RDB和AOF到底该如何选择

(1) 不要仅仅使用RDB，会丢失增量数据。 

(2) 也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug。

(3) 综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。

