# 原码, 反码, 补码

**机器数**: 数值在计算机中的真实存储, **最高位是符号位, 正数为0, 复数为1**

以8位的二进制表示

7 -> 0 0 0 0  0 1 1 1

-7 -> 1 0 0 0  0 1 1 1

**真数**

机器数的真正数值, 可以理解为绝对值



**原码**:  即机器数, 带符号位的真数

**反码**:

- 正数: 与原码相同
- 负数: 符号位为1, 其余对原码取反

**补码**:

- 正数: 与原码相同
- 负数: 符号位为1, 反码+1

> 负数在计算机中是以补码形式存储

```shell
# 以8位为例表示
# 7
原码: 0 0 0 0  0 1 1 1
反码: 0 0 0 0  0 1 1 1
补码: 0 0 0 0  0 1 1 1

# -7
原码: 1 0 0 0  0 1 1 1
反码: 1 1 1 1  1 0 0 0
补码: 1 1 1 1  1 0 0 1 # -7在计算机中的表示形式
```



# 位运算

| 符号 | 描述                     | 运算规则                                       |
| ---- | ------------------------ | ---------------------------------------------- |
| &    | 与                       | 两个位都为1时，结果才为1                       |
| \|   | 或                       | 两个位都为0时，结果才为0                       |
| ^    | 异或                     | 两个位相同为0，相异为1                         |
| ~    | 取反                     | 0变1，1变0                                     |
| <<   | 左移                     | 各二进位全部左移若干位，高位丢弃，低位补0      |
| >>   | 带符号右移               | 如果该数为正，则高位补0，若为负数，则高位补1； |
| >>>  | 无符号右移<br />逻辑右移 | 不管正负, 高位补0                              |



# 加减乘除的实现原理 



## 加法

``` shell
# 4 + 5
0 0 0 0  0 1 0 0
0 0 0 0  0 1 0 1
---------------- (计算机不会直接加)
0 0 0 0  1 0 0 1

# 实现原理

# 第一步: 异或
0 0 0 0  0 1 0 0
0 0 0 0  0 1 0 1
-------异或-------
0 0 0 0  0 0 0 1

# 第二步: 与运算(判断进位, 如果结果是0, 说明没进位, 则计算结束)
0 0 0 0  0 1 0 0
0 0 0 0  0 1 0 1
-------与-------
0 0 0 0  0 1 0 0
# (本次结果非0, 进入第三步骤)

# 第三步: 进位, 将第二步与运算的结果左移一位
0 0 0 0  0 1 0 0
->
0 0 0 0  1 0 0 0

# 第四步: 异或, 第一步与第三部的结果做异或运算
0 0 0 0  0 0 0 1
0 0 0 0  1 0 0 0
-------异或-------
0 0 0 0  1 0 0 1

# 第五步: 与运算, 第一步与第三部的结果做异或运算 (判断进位, 如果结果是0, 说明没进位, 则计算结束)
0 0 0 0  0 0 0 1
0 0 0 0  1 0 0 0
-------与-------
0 0 0 0  0 0 0 0
# 本次结果为0, 计算结束, 结果是最后一次异或的结果
```

可以看出来, 加法运算是 (`异或 + 与运算`)的两轮执行. 异或运算得出结果, 与运算用来判断是否有进位,  有则左移进位, 然后进入第二轮执行. 



## 减法

```shell
# 4-5, 是转化为加法
# => 4 + (-5)

0 0 0 0  0 1 0 0
1 1 1 1  1 0 1 1  # -5的补码
----------------
0 0 0 0  1 0 0 1

过程省略... 

```



# 乘法

乘法：被分解为左移累加, 

```shell
用15(x) * 13(y)来举例，=> 1111 x 1101
乘数与被乘数都以2进制表示, 乘数y的每一个非0的位 都表示被乘数x需要左移多少位. 

# 过程: 
1. y第0位是1(2^0), x左移0位, 得到: 11110
2. y第1位是0, 本次结果: 0
3. y第2位是1(2^2), x左移2位, 得到: 111100
4. y第3位是1(2^3), x左移3位, 得到: 1111000
5. y没有第四位了, 不需要继续左移, 把上面的值想加, 得到的结果乘法运算的结果
```



## 除法

除法：被分解为右移累减去，减法可以转换为加法。

 ```shell
85/6来举例, 85/6 => 1010101/110

# 过程
1.101(0101)左移1位到第3位都小于110，因此商=000
2.1010(101)左移四位是1010,比110大，商=0001,余数=1010-110=100(101)
3.余数100(101)左移一位是1001,比110大，商=00011,余数=1001-110=11(01)
4.余数11(01)左移一位是110,等于110，商=000111,余数=0(1)
5.余数0(1)左移一位是01,小于110,商=0001110,余数=01

因此85/6 => 1010101/110 = 0001110，即14，余数为最后的余数1
 ```

