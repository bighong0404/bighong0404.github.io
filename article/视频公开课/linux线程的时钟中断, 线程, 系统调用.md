- CPU中断 - 时钟中断, 电信号通过元器件"晶振"的规律型号来打断cpu执行, cpu通过IDT(interrupt descriptor table)获取下一个线程的内存地址, 以此实现线程间的切换

- linux kernel把系统内存地址, cpu指令等内核系统调用(Systme call)全部封装起来, 以API形式提供给用户程序调用, 实现了对系统的保护, 而用户程序又能方便地调用到硬件. 

  (CPU有很多指令集， 其中中断（int）是其中一种指令集， CPU收到中断指令后， 会去中断表中去找， 中断表是一个类似map， key为0-255的数值， 这个叫中断值， 由应用产生中断的时候产生， cpu中断主要是根据key找到后面的value，然后将这个值交给内核执行， 将寄存器的值带到内核作为执行参数。)

- io操作, 系统调用指令 int 0x80,让cpu暂定, 把数据写到cpu寄存器, 之后浪费时间. 因此jdk1.6之前的synchronize关键字, 是直接走内核区内存的系统调用(产生中断, 保护现场恢复现场等操作)来实现阻塞. 因此效率低. 而能在用户区内存直接进行cas操作实现锁竞争, 效率非常高.



java的线程跟系统线程是1:1的, 因此比较重. 而go的纤程, 是go语言的自定义的类线程, 创建不需要走系统调用, 因此更加轻量级. 



>  strace -ff -o out /usr/jdk8_15/bin/java SocketBIO
>
>  eg:   strace -ff -o out  /java  xxx  启用追踪, 执行java程序, 展示程序执行的系统调用

 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如**系统调用**、信号传递、进程状态变更等。