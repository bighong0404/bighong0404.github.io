# 前言

**总结**

![img](img/849589-20171015233043168-1867817869.png)

**术语说明**

- **n**: 数据规模
- **k**: “桶”的个数
- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
- **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
- **In-place**：内排序, 所有排序操作都在内存中完成, 不占用额外内存；
- **Out-place**：外排序, 需要占用额外内存. 由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
- **时间复杂度：** 一个算法执行所耗费的时间。
- **空间复杂度**：运行完一个程序所需内存的大小。

**时间复杂度排行**

时间复杂度耗时： 



$ O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) <O(2n) < O(n!) $



**比较与非比较**
常见的**快速排序、归并排序、堆排序、冒泡排序**等属于**比较排序**。**在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。**
在**冒泡排序**之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在**归并排序、快速排序**之类的排序中，问题规模通过**分治法**消减为logN次，所以时间复杂度平均**O(nlogn)**。
**比较排序**的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，**比较排序适用于一切需要排序的情况。**

**计数排序、基数排序、桶排序**则属于**非比较排序**。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。
非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度**O(n)**。
**非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。**


# 1、冒泡排序（Bubble Sort）

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

**算法思路**

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 重复步骤1~3，直到排序完成。

**动图演示**

![img](img/849589-20171015223238449-2146169197.gif)

**代码实现**

```java
public static void bubbleSort(int[] array) {
    if (array == null || array.length == 0) {
        return;
    }
    boolean didSwap;
    //i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i<len-1
    for (int i = 0; i < array.length; i++) {
        didSwap = false;
        //j控制比较次数，第i次循环内需要比较len-i次
        //但是由于是由arr[j]跟arr[j+1]进行比较，所以为了保证arr[j+1]不越界，j<len-i-1
        for (int j = 0; j < array.length - 1 - i; j++) {
            //如果前一个数比后一个数大，则交换位置将大的数往后放。
            if (array[j + 1] < array[j]) {
                int temp = array[j + 1];
                array[j + 1] = array[j];
                array[j] = temp;

                didSwap = true;
            }
        }
        System.out.println("第" + (i + 1) + "次循环之后效果：" + Arrays.toString(array));
        if (!didSwap) {
            // 最佳情况分支: O(n)
            return;
        }
    }
}
```

**算法分析**

最佳情况：$T(n) = O(n)$
最差情况：$T(n) = O(n^2)$
平均情况：$T(n) = O(n^2)$


## 2、选择排序（Selection Sort）

表现**最稳定的排序算法之一**，因为**无论什么数据进去都是O(n^2)的时间复杂度**，所以用到它的时候，数据规模越小越好。

选择排序可以说是冒泡排序的改良版，不再是前一个数跟后一个数相比较，而是在每一次循环内都由一个数去跟所有的数都比较一次.每次比较都选取相对较小的那个数来进行下一次的比较，并不断更新较小数的下标.

这样在一次循环结束时就能得到最小数的下标，再通过一次交换将最小的数放在最前面，通过n-1次循环之后完成排序.
这样相对于冒泡排序来说，比较的次数并没有改变，但是数据交换的次数大大减少。

**算法步骤**

n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

1. 初始状态：无序区为R[1..n]，有序区为空；
2. 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
3. n-1趟结束，数组有序化了。

**动图演示**

![img](img/849589-20171015224719590-1433219824.gif)　　

**代码实现**

`````` java
public static void selectSort(int[] array) {
    if (array == null || array.length == 0) {
        return;
    }

    int len = array.length;
    //i控制循环次数，长度为len的数组只需要循环len-1次，i的起始值为0所以i<len-1
    for (int i = 0; i < len - 1; i++) {
        //minIndex 用来保存每次比较后较小数的下标。
        int minIndex = i;
        //j控制比较次数，因为每次循环结束之后最小的数都已经放在了最前面，
        //所以下一次循环的时候就可以跳过这个数，所以j的初始值为i+1而不需要每次循环都从0开始，并且j<len即可
        for (int j = i + 1; j < len; j++) {
            //每比较一次都需要将较小数的下标记录下来
            if (array[minIndex] > array[j]) {
                minIndex = j;
            }
        }
        //当完成一次循环时，就需要将本次循环选取的最小数移动到本次循环开始的位置。
        if (minIndex != i) {
            int temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;
        }
        System.out.println("第" + (i + 1) + "次循环之后效果：" + Arrays.toString(array));
    }
}
``````

**算法分析**
最佳情况：$T(n) = O(n^2)$
最差情况：$T(n) = O(n^2)$
平均情况：$T(n) = O(n^2)$

## 3、插入排序（Insertion Sort）

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

**算法步骤**
1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。

**动图演示**
![img](img/849589-20171015225645277-1151100000.gif)

**代码实现**
```java
public static void insertSort(int[] arr) {
    if (arr == null) {
        return;
    }
    //i控制循环次数，因为已经默认第一个数的位置是正确的，所以i的起始值为1，i<len，循环len-1次
    for (int i = 1; i < arr.length; i++) {
        //变量j用来记录即将要排序的数的位置即目标数的原位置
        //target用来记录即将要排序的那个数的值即目标值
        int j = i, target = arr[j];

        //while循环用来为目标值在已经排好序的数中找到合适的位置，
        //因为是从后向前比较，并且是与j-1位置的数比较，所以j>0
        while (j > 0 && target < arr[j - 1]) {
            //当目标数的值比它当前位置的前一个数的值小时，将前一个数的位置向后移一位。
            //并且j--使得目标数继续与下一个元素比较
            arr[j] = arr[j - 1];
            j--;
        }
        //目标数插入位置。
        arr[j] = target;
        //打印每次循环结束之后数组的排序状态（方便理解）
        System.out.println("第" + (i) + "次循环之后效果：" + Arrays.toString(arr));
    }
}
```

**算法分析**

最佳情况：$T(n) = O(n)$
最坏情况：$T(n) = O(n^2)$
平均情况：$T(n) = O(n^2)$


## 4、希尔排序（Shell Sort）

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。**希尔排序也是一种插入排序**，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

希尔排序本质上就是把数组的下标按照一定的`增量gap`(即偏移量)分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的值越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。因此是**分治版本的插入排序**. 
eg: 若gap=5, 那么下标0,5,10,15的数据分为一组, 1,6,11,16为一组. 

**折叠基数f与增量gap**

$gap = n / f$
折叠基数的选择非常重要, 直接影响希尔排序性能以及有效性. 由于在gap=1的时候希尔排序才会执行结束, 因此折叠基数建议选择`2或者质数`.

**算法步骤**
在此我们选择折叠系数为2, 增量gap=length/2，缩小增量继续以gap=gap/2的方式，这种增量选择我们可以用一个序列来表示，**{n/2,(n/2)/2...1}**，称为**增量序列**。

- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
- 按增量序列个数k，对序列进行k 趟排序；
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

**4.2 过程演示**
![img](img/1192699-20180319094116040-1638766271.png)

**代码实现**
```java
public static void ShellSort(int[] arr) {
    if (arr == null) {
        return;
    }
    //折叠基数
    int f = 2;
    //初始的增量gap为数组长度的一半
    int gap = arr.length / f;
    System.out.println("len: " + arr.length +", 初始gap: " + gap);

    //while循环控制按增量的值来划不同分子序列，每完成一次增量就减少为原来的一半
    //增量的最小值为1，即最后一次对整个数组做直接插入排序
    while (gap > 0) {
        //里边其实就是升级版的直接插入排序了，是对每一个子序列进行直接插入排序，
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            int target = arr[i];
            while (j >= gap && target < arr[j - gap]) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = target;
        }
        //不同增量排序后的结果
        System.out.println("增量为" + gap + "排序之后：" + Arrays.toString(arr));
        //每完成一次增量就减少为原来的一半
        gap /= f;
    }
}
```

**算法分析**
最佳情况：$T(n) = O(nlog_2n)$
最坏情况：$T(n) = O(nlog_2n)$
平均情况：$T(n) =O(nlog_2n)$

# 5、归并排序（Merge Sort）

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。总体概括就是**从上到下递归拆分，然后从下到上逐步合并**。

**递归拆分**：先把待排序数组分为左右两个子序列，再分别将左右两个子序列拆分为四个子序列，以此类推直到最小的子序列元素的个数为两个或者一个为止。

**逐步合并**（一定要注意是从下到上层级合并，可以理解为递归的层级返回）：将最底层的最左边的一个子序列排序，然后将从左到右第二个子序列进行排序，再将这两个排好序的子序列合并并排序，然后将最底层从左到右第三个子序列进行排序..... 合并完成之后继续完成了对数组的排序操作。

**动画演示**
![归并排序](img/1685c01b7f84849b.gif)

**代码展示**

```java
/**
 * 递归拆分
 * @param arr 待拆分数组
 * @param left 待拆分数组最小下标
 * @param right 待拆分数组最大下标
 */
public static void mergeSort(int[] arr, int left, int right) {
    if(arr == null || left > right){
        return;
    }
    int mid = (left + right) / 2; //中间下标
    if (left < right) {
        mergeSort(arr, left, mid);//递归拆分左边
        mergeSort(arr, mid + 1, right);//递归拆分右边
        sort(arr, left, mid, right);//合并左右
    }
}

/**
 * 合并两个有序子序列
 *
 * @param arr   待合并数组
 * @param left  待合并数组最小下标
 * @param mid   待合并数组中间下标
 * @param right 待合并数组最大下标
 */
private static void sort(int[] arr, int left, int mid, int right) {
    //临时数组，用来保存每次合并年之后的结果
    int[] temp = new int[right - left + 1];
    //临时数组的初始下标
    int k = 0;

    // 左数组下标范围: left ~ mid
    int i = left;
    // 右数组下标范围: mid+1 ~ right
    int j = mid + 1;
    //这个while循环能够初步筛选出待合并的两个子序列中的较小数
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    // 因为经过一系列递归合并操作, 以及上面while循环的操作.
    // 1. 左, 右数组分别是有序的
    // 2. 左边数组的剩余的值肯定比右边的小
    // 因此先将左边序列中剩余的数放入临时数组
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    //将右边序列中剩余的数放入临时数组
    while (j <= right) {
        temp[k++] = arr[j++];
    }

    //将临时数组中的元素覆盖到正式数组中
    for (int m = 0; m < temp.length; m++) {
        arr[m + left] = temp[m];
    }
}
```



# 附录
参考:
https://www.cnblogs.com/guoyaohua/p/8600214.html
https://juejin.im/post/5c40837751882525487c5394#heading-23