
六大原则是基于Java的三大特性(封装、继承、多态)以及抽象和接口，以高重用性，高内聚低耦合等为目的，并结合经验归纳出来的规范。六大原则之间有很多相似指出，只是各自的出发角度不一样而已。代码并不要求严格遵守六大设计原则，要依实际情况而定，就跟数据库设计三大规范一样，不要求100%符合，可以根据情况设置冗余字段。越符合六大原则的代码越是好代码。
#六大原则SOLID
根据6大原则的英文全称，有个方便的记忆方式： `SOLID`。
##1.	单一职责原则The Single Responsibility Principle	
不要存在多于一个导致类变更的原因。换句话，即一个类只负责一项职责。目的是降低逻辑的复杂度，降低耦合，提高代码可读性，是开闭原则的表现之一。
举个例子，远古时期的，项目会把从展示层到DB操作的逻辑都写到一个jsp中，一个jsp做完所有的事情。页面展示要调整，需要动jsp，逻辑修改需要动jsp，表新增字段需要动jsp, 各种各样的修改都很可能要触碰到这个jsp文件, 使得代码及其复杂, 牵一发动全身。
现代的功能分层则解决了这个情况。一处功能分割为展示层View，业务逻辑层Service， 数据库操作层Dao。jsp只负责从后台获取数据展示给客户端，不管获取数据的逻辑。只有界面修改才会动到jsp，获取数据逻辑修改去动关联的service类，跟jsp无关。
##2.	开放封闭原则The Open Closed Principle	
一个软件实体应当对扩展开放，对修改关闭。软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。即对扩展是开放的，而对修改是封闭的。随着时间推移公司发展，业务越来越复杂，原先的业务逻辑代码已经无法支撑现有的业务，需要升级，那么往往都是需要更改到老逻辑代码的。但如果老代码的设计符合开闭原则，抽象程度，接口细分做得足够好，那么功能升级也只需要对抽象或接口进行修改，拓展具体的实现类，而不需要修改到上层应用逻辑。三层架构也是这方面的体现之一。
##3.	里氏替换原则The Liskov Substitution Principle
所有引用基类的地方必须能透明地使用其子类的对象, 并且程序的行为没有发生改变。换句话说：一个基类对象替换成其子类，程序逻辑也不会发生错误或者异常。里氏替换原则是对继承关系中子类行为的约束规范。子类继承父类时候，可以新增自己的方法，但尽量不要重写、重载父类的方法。虽然从语法角度来说，继承确实支持子类重写、重载父类的方法，但重写、重载了父类的方法，有可能会对该父类的继承体系造成破坏，因为父类方法的实现逻辑被修改了，行为发生了改变，很可能造成程序的异常。
因此里氏替换原则通俗来讲就是： 子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：
1)	子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
2)	子类中可以增加自己特有的方法。
3)	当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
4)	当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

因此里氏替换原则也是开闭原则的表现之一。

##4.	接口隔离原则The Interface Segregation Principle	
不能强迫用户去依赖那些他们不使用的接口。假设当一个类A实现了接口A，由于其他业务需要，接口A新增了方法B，那么实现类A就必须修改代码去实现新增的方法B，而A类又没有方法B的需求，这就从另一个角度违反了开闭原则。推荐做法是接口A可以拆分为多个接口，交由实现类去根据业务需求，选择需要实现哪几些接口，达到接口隔离作用。这就是接口隔离原则。
这又是开闭原则的实现方式之一。
##5.	依赖倒置原则The Dependency Inversion Principle	
定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即参数传递，组合关系中，尽量引用一个抽象类或者接口，而不是直接依赖于某个具体的实现类。引入抽象层后，系统将具有很高的灵活性，但有变更时候，只需要对抽象层进行拓展，或者修改实现类，上层调用方不需要变动到。
传递依赖关系有三种方式：接口传递（以上的例子中使用的方法），构造方法传递和setter方法传递。
在实际编程中，我们一般需要做到如下3点：
1) 低层模块尽量都要有抽象类或接口，或者两者都有。
2) 变量的声明类型尽量是抽象类或接口。
3) 使用继承时遵循里氏替换原则。

面向抽象编程，其实也是开闭原则的实现之一。日志门面框架slf4j是典型的应用。
##6.	迪米特法则(最少知道原则)Demeter Principle
一个软件实体应当尽可能少地与其他实体发生相互作用。其实就是低耦合的意思。一个类尽量少跟其他类有交互，类与类之间保持低耦合，尽量降低类内部的属性跟方法的访问权限。
这个原则认为，任何一个对象或者方法，它应该只能调用下列对象：
1) 该对象本身
2) 作为参数传进来的对象（也可以是该对象的字段）
3) 在方法内创建的对象
我对这原则的理解, 可以归纳为一句话: 对象A的持有者才有权操作该对象。
假设类B持有对象A_in_B，业务需求要操作到对象A_in_B中的对象X_in_A，B不能在代码中通过A_in_B的getXInA ()得到A_in_B的内部对象X_in_A, 之后进行修改操作。B只能调用A_in_B对外暴露的public方法去修改X_in_A，修改逻辑是写在A_in_B中的, 并不是写在B中的, 并且A_in_B内部对象X_in_A也不能直接通过某个public方法暴露出去，以免被其他类滥用。在这里面，A_in_B就是B跟X的中介类。
使用迪米特法则需要清晰划分业务模型之间的边界，最大程度减少模型之间的关联性以实现低耦合。

##一句话总结
>六大原则是Java封装、抽象、接口（抽象跟接口衍生出继承、多态）的不同用法。开闭原则是目标，其他5个原则为开闭原则的实现方式。
